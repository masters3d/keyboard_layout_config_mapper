package generators

import (
	"fmt"
	"strings"
	"masters3d.com/keyboard_layout_config_mapper/internal/models"
)

// ZMKGenerator generates ZMK keymap files from keyboard layouts
type ZMKGenerator struct {
	keyboardType models.KeyboardType
}

// NewZMKGenerator creates a new ZMK keymap generator
func NewZMKGenerator(keyboardType models.KeyboardType) *ZMKGenerator {
	return &ZMKGenerator{
		keyboardType: keyboardType,
	}
}

// Generate creates a ZMK keymap file content from a keyboard layout
func (g *ZMKGenerator) Generate(layout *models.KeyboardLayout) (string, error) {
	var sb strings.Builder
	
	// Write header
	g.writeHeader(&sb, layout)
	
	// Write defines
	g.writeDefines(&sb, layout)
	
	// Write opening
	sb.WriteString("\n/ {\n")
	
	// Write macros first (ZMK requires macros before behaviors that use them)
	g.writeMacrosSection(&sb, layout)
	
	// Write behaviors
	if len(layout.Behaviors) > 0 {
		g.writeBehaviors(&sb, layout)
	}
	
	// Write keymap
	g.writeKeymap(&sb, layout)
	
	// Close root
	sb.WriteString("};\n")
	
	return sb.String(), nil
}

// writeHeader writes the file header
func (g *ZMKGenerator) writeHeader(sb *strings.Builder, layout *models.KeyboardLayout) {
	sb.WriteString("/*\n")
	sb.WriteString(" * Copyright (c) 2020 The ZMK Contributors\n")
	sb.WriteString(" * \n")
	sb.WriteString(" * SPDX-License-Identifier: MIT\n")
	sb.WriteString(" * \n")
	
	// Write keyboard-specific header based on type
	switch g.keyboardType {
	case models.KeyboardZMKAdvMod:
		sb.WriteString(" * ZMK keymap for Kinesis Advantage keyboards using Pillz Mod + Nice!Nano\n")
		sb.WriteString(" * Compatible with KLCM (Keyboard Layout Config Mapper)\n")
		sb.WriteString(" * \n")
		sb.WriteString(" * Hardware: Kinesis Advantage with Pillz Mod Pro + Nice!Nano v2\n")
		sb.WriteString(" * Repository: https://github.com/masters3d/zmk-config-pillzmod-nicenano\n")
		sb.WriteString(" * Branch: cheyo\n")
	case models.KeyboardZMKGlove80:
		sb.WriteString(" * ZMK keymap for MoErgo Glove80\n")
		sb.WriteString(" * Generated by KLCM (Keyboard Layout Config Mapper)\n")
	case models.KeyboardZMKAdv360:
		sb.WriteString(" * ZMK keymap for Kinesis Advantage 360 Pro\n")
		sb.WriteString(" * Generated by KLCM (Keyboard Layout Config Mapper)\n")
	default:
		sb.WriteString(fmt.Sprintf(" * ZMK keymap for %s\n", g.keyboardType))
		sb.WriteString(" * Generated by KLCM (Keyboard Layout Config Mapper)\n")
	}
	sb.WriteString(" */\n\n")
	
	// Include headers
	sb.WriteString("#include <behaviors.dtsi>\n")
	sb.WriteString("#include <dt-bindings/zmk/keys.h>\n")
	sb.WriteString("#include <dt-bindings/zmk/bt.h>\n")
	
	// Add hardware-specific includes
	switch g.keyboardType {
	case models.KeyboardZMKAdv360:
		sb.WriteString("#include <dt-bindings/zmk/rgb.h>\n")
		sb.WriteString("#include <dt-bindings/zmk/backlight.h>\n")
	case models.KeyboardZMKAdvMod:
		sb.WriteString("#include <dt-bindings/zmk/outputs.h>\n")
	}
	sb.WriteString("\n")
}

// writeDefines writes layer defines
func (g *ZMKGenerator) writeDefines(sb *strings.Builder, layout *models.KeyboardLayout) {
	// For adv_mod, use specific layer numbering
	if g.keyboardType == models.KeyboardZMKAdvMod {
		sb.WriteString("#define LAYER_KEYPAD 1\n")
		sb.WriteString("#define LAYER_CMD 2\n")
		sb.WriteString("#define LAYER_SYSTEM 3\n")
		sb.WriteString("\n")
		return
	}
	
	// For other keyboards, derive from layers
	for _, layer := range layout.Layers {
		if layer.Index > 0 && layer.Name != "padding" && !strings.Contains(layer.Name, "padding") {
			layerName := strings.ToUpper(layer.Name)
			// Clean up layer name (remove "layer" prefix if present)
			layerName = strings.TrimPrefix(layerName, "LAYER")
			layerName = strings.TrimPrefix(layerName, "_")
			if layerName != "" && layerName != "DEFAULT" {
				sb.WriteString(fmt.Sprintf("#define LAYER_%s %d\n", layerName, layer.Index))
			}
		}
	}
	sb.WriteString("\n")
}

// writeBehaviors writes custom behaviors
func (g *ZMKGenerator) writeBehaviors(sb *strings.Builder, layout *models.KeyboardLayout) {
	sb.WriteString("    behaviors {\n")
	
	// Standard behaviors
	sb.WriteString("        mo_key: behavior_mo_key {\n")
	sb.WriteString("            compatible = \"zmk,behavior-hold-tap\";\n")
	sb.WriteString("            label = \"mo_key\";\n")
	sb.WriteString("            #binding-cells = <2>;\n")
	sb.WriteString("            tapping-term-ms = <200>;\n")
	sb.WriteString("            quick_tap_ms = <175>;\n")
	sb.WriteString("            flavor = \"tap-preferred\";\n")
	sb.WriteString("            bindings = <&mo>, <&kp>;\n")
	sb.WriteString("        };\n\n")
	
	sb.WriteString("        hm: homerow_mods {\n")
	sb.WriteString("            compatible = \"zmk,behavior-hold-tap\";\n")
	sb.WriteString("            label = \"HOMEROW_MODS\";\n")
	sb.WriteString("            #binding-cells = <2>;\n")
	sb.WriteString("            tapping-term-ms = <200>;\n")
	sb.WriteString("            quick_tap_ms = <175>;\n")
	sb.WriteString("            flavor = \"tap-preferred\";\n")
	sb.WriteString("            bindings = <&kp>, <&kp>;\n")
	sb.WriteString("        };\n\n")
	
	// Mod-morph behaviors (if any morphed keys detected)
	g.writeMorphBehaviors(sb, layout)
	
	sb.WriteString("    };\n\n")
}

// writeMacrosSection writes macros in a separate section (ZMK format)
func (g *ZMKGenerator) writeMacrosSection(sb *strings.Builder, layout *models.KeyboardLayout) {
	macros := g.detectMacros(layout)
	if len(macros) == 0 {
		return
	}
	
	sb.WriteString("    macros {\n")
	
	if macros["macro_brackets"] {
		sb.WriteString("        macro_brackets: macro_brackets {\n")
		sb.WriteString("            compatible = \"zmk,behavior-macro\";\n")
		sb.WriteString("            label = \"macro_brackets\";\n")
		sb.WriteString("            #binding-cells = <0>;\n")
		sb.WriteString("            bindings = <&kp LBKT>, <&kp RBKT>, <&kp LEFT>;\n")
		sb.WriteString("        };\n\n")
	}
	
	if macros["macro_braces"] {
		sb.WriteString("        macro_braces: macro_braces {\n")
		sb.WriteString("            compatible = \"zmk,behavior-macro\";\n")
		sb.WriteString("            label = \"macro_braces\";\n")
		sb.WriteString("            #binding-cells = <0>;\n")
		sb.WriteString("            bindings = <&kp LBRC>, <&kp RBRC>, <&kp LEFT>;\n")
		sb.WriteString("        };\n\n")
	}
	
	if macros["macro_parens"] {
		sb.WriteString("        macro_parens: macro_parens {\n")
		sb.WriteString("            compatible = \"zmk,behavior-macro\";\n")
		sb.WriteString("            label = \"macro_parens\";\n")
		sb.WriteString("            #binding-cells = <0>;\n")
		sb.WriteString("            bindings = <&kp LPAR>, <&kp RPAR>, <&kp LEFT>;\n")
		sb.WriteString("        };\n\n")
	}
	
	if macros["macro_angle_brackets"] {
		sb.WriteString("        macro_angle_brackets: macro_angle_brackets {\n")
		sb.WriteString("            compatible = \"zmk,behavior-macro\";\n")
		sb.WriteString("            label = \"macro_angle_brackets\";\n")
		sb.WriteString("            #binding-cells = <0>;\n")
		sb.WriteString("            bindings = <&kp LT>, <&kp GT>, <&kp LEFT>;\n")
		sb.WriteString("        };\n\n")
	}
	
	sb.WriteString("    };\n\n")
}

// detectMacros scans the layout for macro references
func (g *ZMKGenerator) detectMacros(layout *models.KeyboardLayout) map[string]bool {
	macros := make(map[string]bool)
	for _, layer := range layout.Layers {
		for _, binding := range layer.Bindings {
			if strings.HasPrefix(binding.Value, "&macro_") {
				// Extract macro name without the &
				macroName := strings.TrimPrefix(binding.Value, "&")
				macros[macroName] = true
			}
		}
	}
	return macros
}

// writeMorphBehaviors writes mod-morph behaviors based on detected morph keys
func (g *ZMKGenerator) writeMorphBehaviors(sb *strings.Builder, layout *models.KeyboardLayout) {
	morphs := make(map[string]bool)
	
	// Scan all layers for morphed keys
	for _, layer := range layout.Layers {
		for _, binding := range layer.Bindings {
			if strings.HasPrefix(binding.Value, "&morph_") {
				morphs[binding.Value] = true
			}
		}
	}
	
	// Write the morph behaviors we found
	if morphs["&morph_dot"] {
		sb.WriteString("        // &dot_override,\n")
		sb.WriteString("        morph_dot: morph_dot {\n")
		sb.WriteString("            compatible = \"zmk,behavior-mod-morph\";\n")
		sb.WriteString("            label = \"MORPH_DOT\";\n")
		sb.WriteString("            #binding-cells = <0>;\n")
		sb.WriteString("            bindings = <&kp PERIOD>, <&kp COLON>;\n")
		sb.WriteString("            mods = <(MOD_LSFT|MOD_RSFT)>;\n")
		sb.WriteString("        };\n\n")
	}
	
	if morphs["&morph_comma"] {
		sb.WriteString("        // &comma_override,\n")
		sb.WriteString("        morph_comma: morph_comma {\n")
		sb.WriteString("            compatible = \"zmk,behavior-mod-morph\";\n")
		sb.WriteString("            label = \"MORPH_COMMA\";\n")
		sb.WriteString("            #binding-cells = <0>;\n")
		sb.WriteString("            bindings = <&kp COMMA>, <&kp SEMICOLON>;\n")
		sb.WriteString("            mods = <(MOD_LSFT|MOD_RSFT)>;\n")
		sb.WriteString("        };\n\n")
	}
	
	if morphs["&morph_parens_left"] {
		sb.WriteString("        // &parens_left_override,\n")
		sb.WriteString("        morph_parens_left: morph_parens_left {\n")
		sb.WriteString("            compatible = \"zmk,behavior-mod-morph\";\n")
		sb.WriteString("            label = \"MORPH_PARENS_LEFT\";\n")
		sb.WriteString("            #binding-cells = <0>;\n")
		sb.WriteString("            bindings = <&kp LEFT_PARENTHESIS>, <&kp LESS_THAN>;\n")
		sb.WriteString("            mods = <(MOD_LSFT|MOD_RSFT)>;\n")
		sb.WriteString("        };\n\n")
	}
	
	if morphs["&morph_parens_right"] {
		sb.WriteString("        // &parens_right_override,\n")
		sb.WriteString("        morph_parens_right: morph_parens_right {\n")
		sb.WriteString("            compatible = \"zmk,behavior-mod-morph\";\n")
		sb.WriteString("            label = \"MORPH_PARENS_RIGHT\";\n")
		sb.WriteString("            #binding-cells = <0>;\n")
		sb.WriteString("            bindings = <&kp RIGHT_PARENTHESIS>, <&kp GREATER_THAN>;\n")
		sb.WriteString("            mods = <(MOD_LSFT|MOD_RSFT)>;\n")
		sb.WriteString("        };\n\n")
	}
	
	if morphs["&morph_exclamation"] {
		sb.WriteString("        // &exclamation_override,\n")
		sb.WriteString("        morph_exclamation: morph_exclamation {\n")
		sb.WriteString("            compatible = \"zmk,behavior-mod-morph\";\n")
		sb.WriteString("            label = \"MORPH_EXCLAMATION\";\n")
		sb.WriteString("            #binding-cells = <0>;\n")
		sb.WriteString("            bindings = <&kp BACKSLASH>, <&kp EXCLAMATION>;\n")
		sb.WriteString("            mods = <(MOD_LSFT|MOD_RSFT)>;\n")
		sb.WriteString("        };\n\n")
	}
	
	if morphs["&morph_quote_single"] {
		sb.WriteString("        // &quote_single_override,\n")
		sb.WriteString("        morph_quote_single: morph_quote_single {\n")
		sb.WriteString("            compatible = \"zmk,behavior-mod-morph\";\n")
		sb.WriteString("            label = \"MORPH_QUOTE_SINGLE\";\n")
		sb.WriteString("            #binding-cells = <0>;\n")
		sb.WriteString("            bindings = <&kp SINGLE_QUOTE>, <&kp GRAVE>;\n")
		sb.WriteString("            mods = <(MOD_LSFT|MOD_RSFT)>;\n")
		sb.WriteString("        };\n\n")
	}
	
	if morphs["&morph_quote_double"] {
		sb.WriteString("        // &quote_double_override,\n")
		sb.WriteString("        morph_quote_double: morph_quote_double {\n")
		sb.WriteString("            compatible = \"zmk,behavior-mod-morph\";\n")
		sb.WriteString("            label = \"MORPH_QUOTE_DOUBLE\";\n")
		sb.WriteString("            #binding-cells = <0>;\n")
		sb.WriteString("            bindings = <&kp DOUBLE_QUOTES>, <&kp TILDE>;\n")
		sb.WriteString("            mods = <(MOD_LSFT|MOD_RSFT)>;\n")
		sb.WriteString("        };\n\n")
	}
}

// writeKeymap writes the keymap section
func (g *ZMKGenerator) writeKeymap(sb *strings.Builder, layout *models.KeyboardLayout) {
	sb.WriteString("    keymap {\n")
	sb.WriteString("        compatible = \"zmk,keymap\";\n\n")
	
	for _, layer := range layout.Layers {
		// Skip padding layers
		if strings.Contains(strings.ToLower(layer.Name), "padding") {
			continue
		}
		g.writeLayer(sb, &layer)
	}
	
	sb.WriteString("    };\n")
}

// writeLayer writes a single layer
func (g *ZMKGenerator) writeLayer(sb *strings.Builder, layer *models.Layer) {
	// Determine semantic layer name
	layerName := g.getSemanticLayerName(layer)
	sb.WriteString(fmt.Sprintf("        %s {\n", layerName))
	
	// Write comment with layer description
	comment := g.getLayerComment(layer)
	sb.WriteString(fmt.Sprintf("            // %s\n", comment))
	
	// Write bindings
	sb.WriteString("            bindings = <\n")
	g.writeBindings(sb, layer)
	sb.WriteString("            >;\n")
	
	sb.WriteString("        };\n\n")
}

// getSemanticLayerName returns a semantic layer name based on the layer content/name
func (g *ZMKGenerator) getSemanticLayerName(layer *models.Layer) string {
	name := strings.ToLower(layer.Name)
	
	// Map common layer names to semantic names
	switch {
	case layer.Index == 0 || strings.Contains(name, "default"):
		return "default_layer"
	case strings.Contains(name, "qwerty"):
		return "qwerty_layer"
	case strings.Contains(name, "keypad") || strings.Contains(name, "numpad"):
		return "keypad_layer"
	case strings.Contains(name, "cmd") || strings.Contains(name, "fn"):
		return "cmd_layer"
	case strings.Contains(name, "mod") || strings.Contains(name, "system"):
		return "system_layer"
	case strings.Contains(name, "mapping"):
		return "mapping_layer"
	default:
		// Use the original name with _layer suffix
		cleanName := strings.ReplaceAll(name, " ", "_")
		return cleanName + "_layer"
	}
}

// getLayerComment returns a descriptive comment for the layer
func (g *ZMKGenerator) getLayerComment(layer *models.Layer) string {
	name := strings.ToLower(layer.Name)
	
	switch {
	case layer.Index == 0 || strings.Contains(name, "default"):
		return "Default layer - Main typing layer with custom modifications"
	case strings.Contains(name, "keypad"):
		return "Keypad layer - Number pad with symbols and macros for brackets/braces"
	case strings.Contains(name, "cmd") || strings.Contains(name, "fn"):
		return "CMD/FN layer - Control/Command key combinations for all keys"
	case strings.Contains(name, "system") || strings.Contains(name, "mod"):
		return "System layer - Bluetooth, output selection, bootloader access"
	case strings.Contains(name, "mapping"):
		return "Mapping layer - Key identity definitions for cross-keyboard translation"
	default:
		return fmt.Sprintf("Layer %d: %s", layer.Index, layer.Name)
	}
}

// writeBindings writes the bindings for a layer
func (g *ZMKGenerator) writeBindings(sb *strings.Builder, layer *models.Layer) {
	// For Advanced Mod: 18-key top row + 6 rows of main/thumb keys
	// The layout needs to match the physical keyboard matrix
	
	if g.keyboardType == models.KeyboardZMKAdvMod {
		g.writeAdvModBindings(sb, layer)
	} else {
		// Generic fallback
		g.writeGenericBindings(sb, layer)
	}
}

// writeAdvModBindings writes bindings in Advanced Mod format
// Physical layout (86 keys total):
//   Row 0: 18 keys (function row - 9 left + 9 right, no gap)
//   Row 1: 6 left + 6 right = 12 (number/symbol row)
//   Row 2: 6 left + 6 right = 12 (QWERTY row)
//   Row 3: 6 left + 6 right = 12 (home row)
//   Row 4: 6 left + 6 right = 12 (bottom alpha row)
//   Row 5: 4 left + 4 right = 8 (modifier row, indented)
//   Row 6: 2 left + 2 right = 4 (thumb top)
//   Row 7: 1 left + 1 right = 2 (thumb middle)
//   Row 8: 3 left + 3 right = 6 (thumb bottom)
func (g *ZMKGenerator) writeAdvModBindings(sb *strings.Builder, layer *models.Layer) {
	// Group bindings by position for organized output
	bindingMap := make(map[string]string)
	for _, binding := range layer.Bindings {
		key := fmt.Sprintf("%s_%d_%d", binding.Position.Side, binding.Position.Row, binding.Position.Col)
		bindingMap[key] = binding.Value
	}

	// Helper to get binding or &trans
	getBinding := func(side string, row, col int) string {
		key := fmt.Sprintf("%s_%d_%d", side, row, col)
		if val, ok := bindingMap[key]; ok {
			return val
		}
		return "&trans"
	}

	// Row 0: Function row (18 keys, 9 left + 9 right, continuous line)
	sb.WriteString("    ")
	for col := 0; col < 9; col++ {
		sb.WriteString(getBinding("left", 0, col))
		sb.WriteString("  ")
	}
	for col := 0; col < 9; col++ {
		sb.WriteString(getBinding("right", 0, col))
		if col < 8 {
			sb.WriteString("  ")
		}
	}
	sb.WriteString("\n")

	// Rows 1-4: Main keyboard rows (6 left + gap + 6 right)
	for row := 1; row <= 4; row++ {
		sb.WriteString("    ")
		// Left side (6 keys)
		for col := 0; col < 6; col++ {
			sb.WriteString(getBinding("left", row, col))
			sb.WriteString("  ")
		}
		// Gap between hands
		sb.WriteString("                                                   ")
		// Right side (6 keys)
		for col := 0; col < 6; col++ {
			sb.WriteString(getBinding("right", row, col))
			if col < 5 {
				sb.WriteString("  ")
			}
		}
		sb.WriteString("\n")
	}

	// Row 5: Modifier row (4 left + gap + 4 right, indented)
	sb.WriteString("            ")
	for col := 0; col < 4; col++ {
		sb.WriteString(getBinding("left", 5, col))
		sb.WriteString("  ")
	}
	sb.WriteString("                                                                  ")
	for col := 0; col < 4; col++ {
		sb.WriteString(getBinding("right", 5, col))
		if col < 3 {
			sb.WriteString("  ")
		}
	}
	sb.WriteString("\n")

	// Row 6: Thumb top (2 left + gap + 2 right)
	sb.WriteString("                                                  ")
	for col := 0; col < 2; col++ {
		sb.WriteString(getBinding("left", 6, col))
		sb.WriteString("  ")
	}
	sb.WriteString("                                      ")
	for col := 0; col < 2; col++ {
		sb.WriteString(getBinding("right", 6, col))
		if col < 1 {
			sb.WriteString("  ")
		}
	}
	sb.WriteString("\n")

	// Row 7: Thumb middle (1 left + gap + 1 right)
	sb.WriteString("                                                          ")
	sb.WriteString(getBinding("left", 7, 0))
	sb.WriteString("                                      ")
	sb.WriteString(getBinding("right", 7, 0))
	sb.WriteString("\n")

	// Row 8: Thumb bottom (3 left + gap + 3 right)
	sb.WriteString("                                        ")
	for col := 0; col < 3; col++ {
		sb.WriteString(getBinding("left", 8, col))
		sb.WriteString("  ")
	}
	sb.WriteString("                                      ")
	for col := 0; col < 3; col++ {
		sb.WriteString(getBinding("right", 8, col))
		if col < 2 {
			sb.WriteString("  ")
		}
	}
	sb.WriteString("\n")
}

// writeGenericBindings writes bindings in a generic format
func (g *ZMKGenerator) writeGenericBindings(sb *strings.Builder, layer *models.Layer) {
	// Simple row-based output
	currentRow := -1
	sb.WriteString("    ")
	
	for i, binding := range layer.Bindings {
		if binding.Position.Row != currentRow {
			if currentRow >= 0 {
				sb.WriteString("\n    ")
			}
			currentRow = binding.Position.Row
		}
		
		sb.WriteString(binding.Value)
		if i < len(layer.Bindings)-1 {
			sb.WriteString("  ")
		}
	}
	sb.WriteString("\n")
}
