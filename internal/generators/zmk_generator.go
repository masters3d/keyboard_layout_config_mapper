package generators

import (
	"fmt"
	"strings"
	"masters3d.com/keyboard_layout_config_mapper/internal/models"
)

// ZMKGenerator generates ZMK keymap files from keyboard layouts
type ZMKGenerator struct {
	keyboardType models.KeyboardType
}

// NewZMKGenerator creates a new ZMK keymap generator
func NewZMKGenerator(keyboardType models.KeyboardType) *ZMKGenerator {
	return &ZMKGenerator{
		keyboardType: keyboardType,
	}
}

// Generate creates a ZMK keymap file content from a keyboard layout
func (g *ZMKGenerator) Generate(layout *models.KeyboardLayout) (string, error) {
	var sb strings.Builder
	
	// Write header
	g.writeHeader(&sb, layout)
	
	// Write defines
	g.writeDefines(&sb, layout)
	
	// Write opening
	sb.WriteString("\n/ {\n")
	
	// Write behaviors
	if len(layout.Behaviors) > 0 {
		g.writeBehaviors(&sb, layout)
	}
	
	// Write keymap
	g.writeKeymap(&sb, layout)
	
	// Close root
	sb.WriteString("};\n")
	
	return sb.String(), nil
}

// writeHeader writes the file header
func (g *ZMKGenerator) writeHeader(sb *strings.Builder, layout *models.KeyboardLayout) {
	sb.WriteString("/*\n")
	sb.WriteString(" * Copyright (c) 2020 The ZMK Contributors\n")
	sb.WriteString(" * \n")
	sb.WriteString(" * SPDX-License-Identifier: MIT\n")
	sb.WriteString(" * \n")
	sb.WriteString(fmt.Sprintf(" * ZMK keymap for %s\n", g.keyboardType))
	sb.WriteString(" * Generated by KLCM (Keyboard Layout Config Mapper)\n")
	sb.WriteString(fmt.Sprintf(" * Source: %s\n", layout.Metadata["source"]))
	sb.WriteString(" */\n\n")
	
	// Include headers
	sb.WriteString("#include <behaviors.dtsi>\n")
	sb.WriteString("#include <dt-bindings/zmk/keys.h>\n")
	sb.WriteString("#include <dt-bindings/zmk/bt.h>\n")
	
	// Add hardware-specific includes
	switch g.keyboardType {
	case models.KeyboardZMKAdv360:
		sb.WriteString("#include <dt-bindings/zmk/rgb.h>\n")
		sb.WriteString("#include <dt-bindings/zmk/backlight.h>\n")
	case models.KeyboardZMKAdvMod:
		sb.WriteString("#include <dt-bindings/zmk/outputs.h>\n")
	}
	sb.WriteString("\n")
}

// writeDefines writes layer defines
func (g *ZMKGenerator) writeDefines(sb *strings.Builder, layout *models.KeyboardLayout) {
	// Find non-default layers
	for _, layer := range layout.Layers {
		if layer.Index > 0 && layer.Name != "padding" {
			layerName := strings.ToUpper(layer.Name)
			sb.WriteString(fmt.Sprintf("#define LAYER_%s %d\n", layerName, layer.Index))
		}
	}
	sb.WriteString("\n")
}

// writeBehaviors writes custom behaviors
func (g *ZMKGenerator) writeBehaviors(sb *strings.Builder, layout *models.KeyboardLayout) {
	sb.WriteString("    behaviors {\n")
	
	// Standard behaviors
	sb.WriteString("        mo_key: behavior_mo_key {\n")
	sb.WriteString("            compatible = \"zmk,behavior-hold-tap\";\n")
	sb.WriteString("            label = \"mo_key\";\n")
	sb.WriteString("            #binding-cells = <2>;\n")
	sb.WriteString("            tapping-term-ms = <200>;\n")
	sb.WriteString("            quick_tap_ms = <175>;\n")
	sb.WriteString("            flavor = \"tap-preferred\";\n")
	sb.WriteString("            bindings = <&mo>, <&kp>;\n")
	sb.WriteString("        };\n\n")
	
	sb.WriteString("        hm: homerow_mods {\n")
	sb.WriteString("            compatible = \"zmk,behavior-hold-tap\";\n")
	sb.WriteString("            label = \"HOMEROW_MODS\";\n")
	sb.WriteString("            #binding-cells = <2>;\n")
	sb.WriteString("            tapping-term-ms = <200>;\n")
	sb.WriteString("            quick_tap_ms = <175>;\n")
	sb.WriteString("            flavor = \"tap-preferred\";\n")
	sb.WriteString("            bindings = <&kp>, <&kp>;\n")
	sb.WriteString("        };\n\n")
	
	// Mod-morph behaviors (if any morphed keys detected)
	g.writeMorphBehaviors(sb, layout)
	
	// Macro behaviors
	g.writeMacros(sb, layout)
	
	sb.WriteString("    };\n\n")
}

// writeMorphBehaviors writes mod-morph behaviors based on detected morph keys
func (g *ZMKGenerator) writeMorphBehaviors(sb *strings.Builder, layout *models.KeyboardLayout) {
	morphs := make(map[string]bool)
	
	// Scan all layers for morphed keys
	for _, layer := range layout.Layers {
		for _, binding := range layer.Bindings {
			if strings.HasPrefix(binding.Value, "&morph_") {
				morphs[binding.Value] = true
			}
		}
	}
	
	// Write the morph behaviors we found
	if morphs["&morph_dot"] {
		sb.WriteString("        morph_dot: morph_dot {\n")
		sb.WriteString("            compatible = \"zmk,behavior-mod-morph\";\n")
		sb.WriteString("            label = \"MORPH_DOT\";\n")
		sb.WriteString("            #binding-cells = <0>;\n")
		sb.WriteString("            bindings = <&kp PERIOD>, <&kp COLON>;\n")
		sb.WriteString("            mods = <(MOD_LSFT|MOD_RSFT)>;\n")
		sb.WriteString("        };\n\n")
	}
	
	if morphs["&morph_comma"] {
		sb.WriteString("        morph_comma: morph_comma {\n")
		sb.WriteString("            compatible = \"zmk,behavior-mod-morph\";\n")
		sb.WriteString("            label = \"MORPH_COMMA\";\n")
		sb.WriteString("            #binding-cells = <0>;\n")
		sb.WriteString("            bindings = <&kp COMMA>, <&kp SEMICOLON>;\n")
		sb.WriteString("            mods = <(MOD_LSFT|MOD_RSFT)>;\n")
		sb.WriteString("        };\n\n")
	}
	
	if morphs["&morph_parens_left"] {
		sb.WriteString("        morph_parens_left: morph_parens_left {\n")
		sb.WriteString("            compatible = \"zmk,behavior-mod-morph\";\n")
		sb.WriteString("            label = \"MORPH_PARENS_LEFT\";\n")
		sb.WriteString("            #binding-cells = <0>;\n")
		sb.WriteString("            bindings = <&kp LEFT_PARENTHESIS>, <&kp LESS_THAN>;\n")
		sb.WriteString("            mods = <(MOD_LSFT|MOD_RSFT)>;\n")
		sb.WriteString("        };\n\n")
	}
	
	if morphs["&morph_parens_right"] {
		sb.WriteString("        morph_parens_right: morph_parens_right {\n")
		sb.WriteString("            compatible = \"zmk,behavior-mod-morph\";\n")
		sb.WriteString("            label = \"MORPH_PARENS_RIGHT\";\n")
		sb.WriteString("            #binding-cells = <0>;\n")
		sb.WriteString("            bindings = <&kp RIGHT_PARENTHESIS>, <&kp GREATER_THAN>;\n")
		sb.WriteString("            mods = <(MOD_LSFT|MOD_RSFT)>;\n")
		sb.WriteString("        };\n\n")
	}
	
	if morphs["&morph_exclamation"] {
		sb.WriteString("        morph_exclamation: morph_exclamation {\n")
		sb.WriteString("            compatible = \"zmk,behavior-mod-morph\";\n")
		sb.WriteString("            label = \"MORPH_EXCLAMATION\";\n")
		sb.WriteString("            #binding-cells = <0>;\n")
		sb.WriteString("            bindings = <&kp BACKSLASH>, <&kp EXCLAMATION>;\n")
		sb.WriteString("            mods = <(MOD_LSFT|MOD_RSFT)>;\n")
		sb.WriteString("        };\n\n")
	}
	
	if morphs["&morph_quote_single"] {
		sb.WriteString("        morph_quote_single: morph_quote_single {\n")
		sb.WriteString("            compatible = \"zmk,behavior-mod-morph\";\n")
		sb.WriteString("            label = \"MORPH_QUOTE_SINGLE\";\n")
		sb.WriteString("            #binding-cells = <0>;\n")
		sb.WriteString("            bindings = <&kp SINGLE_QUOTE>, <&kp GRAVE>;\n")
		sb.WriteString("            mods = <(MOD_LSFT|MOD_RSFT)>;\n")
		sb.WriteString("        };\n\n")
	}
	
	if morphs["&morph_quote_double"] {
		sb.WriteString("        morph_quote_double: morph_quote_double {\n")
		sb.WriteString("            compatible = \"zmk,behavior-mod-morph\";\n")
		sb.WriteString("            label = \"MORPH_QUOTE_DOUBLE\";\n")
		sb.WriteString("            #binding-cells = <0>;\n")
		sb.WriteString("            bindings = <&kp DOUBLE_QUOTES>, <&kp TILDE>;\n")
		sb.WriteString("            mods = <(MOD_LSFT|MOD_RSFT)>;\n")
		sb.WriteString("        };\n\n")
	}
}

// writeMacros writes macro definitions
func (g *ZMKGenerator) writeMacros(sb *strings.Builder, layout *models.KeyboardLayout) {
	macros := make(map[string]bool)
	
	// Scan for macros
	for _, layer := range layout.Layers {
		for _, binding := range layer.Bindings {
			if strings.HasPrefix(binding.Value, "&macro_") {
				macros[binding.Value] = true
			}
		}
	}
	
	if macros["&macro_brackets"] {
		sb.WriteString("        macro_brackets: macro_brackets {\n")
		sb.WriteString("            compatible = \"zmk,behavior-macro\";\n")
		sb.WriteString("            label = \"BRACKETS\";\n")
		sb.WriteString("            #binding-cells = <0>;\n")
		sb.WriteString("            bindings = <&kp LBKT &kp RBKT &kp LEFT>;\n")
		sb.WriteString("        };\n\n")
	}
	
	if macros["&macro_braces"] {
		sb.WriteString("        macro_braces: macro_braces {\n")
		sb.WriteString("            compatible = \"zmk,behavior-macro\";\n")
		sb.WriteString("            label = \"BRACES\";\n")
		sb.WriteString("            #binding-cells = <0>;\n")
		sb.WriteString("            bindings = <&kp LBRC &kp RBRC &kp LEFT>;\n")
		sb.WriteString("        };\n\n")
	}
	
	if macros["&macro_parens"] {
		sb.WriteString("        macro_parens: macro_parens {\n")
		sb.WriteString("            compatible = \"zmk,behavior-macro\";\n")
		sb.WriteString("            label = \"PARENS\";\n")
		sb.WriteString("            #binding-cells = <0>;\n")
		sb.WriteString("            bindings = <&kp LPAR &kp RPAR &kp LEFT>;\n")
		sb.WriteString("        };\n\n")
	}
	
	if macros["&macro_angle_brackets"] {
		sb.WriteString("        macro_angle_brackets: macro_angle_brackets {\n")
		sb.WriteString("            compatible = \"zmk,behavior-macro\";\n")
		sb.WriteString("            label = \"ANGLE_BRACKETS\";\n")
		sb.WriteString("            #binding-cells = <0>;\n")
		sb.WriteString("            bindings = <&kp LT &kp GT &kp LEFT>;\n")
		sb.WriteString("        };\n\n")
	}
}

// writeKeymap writes the keymap section
func (g *ZMKGenerator) writeKeymap(sb *strings.Builder, layout *models.KeyboardLayout) {
	sb.WriteString("    keymap {\n")
	sb.WriteString("        compatible = \"zmk,keymap\";\n\n")
	
	for _, layer := range layout.Layers {
		g.writeLayer(sb, &layer)
	}
	
	sb.WriteString("    };\n")
}

// writeLayer writes a single layer
func (g *ZMKGenerator) writeLayer(sb *strings.Builder, layer *models.Layer) {
	// Write layer name
	layerName := fmt.Sprintf("layer%d_%s", layer.Index, layer.Name)
	sb.WriteString(fmt.Sprintf("        %s {\n", layerName))
	
	// Write comment
	sb.WriteString(fmt.Sprintf("            // Layer %d: %s\n", layer.Index, layer.Name))
	
	// Write bindings
	sb.WriteString("            bindings = <\n")
	g.writeBindings(sb, layer)
	sb.WriteString("            >;\n")
	
	sb.WriteString("        };\n\n")
}

// writeBindings writes the bindings for a layer
func (g *ZMKGenerator) writeBindings(sb *strings.Builder, layer *models.Layer) {
	// For Advanced Mod: 18-key top row + 6 rows of main/thumb keys
	// The layout needs to match the physical keyboard matrix
	
	if g.keyboardType == models.KeyboardZMKAdvMod {
		g.writeAdvModBindings(sb, layer)
	} else {
		// Generic fallback
		g.writeGenericBindings(sb, layer)
	}
}

// writeAdvModBindings writes bindings in Advanced Mod format
func (g *ZMKGenerator) writeAdvModBindings(sb *strings.Builder, layer *models.Layer) {
	// Group bindings by position for organized output
	bindingMap := make(map[string]string)
	for _, binding := range layer.Bindings {
		key := fmt.Sprintf("%s_%d_%d", binding.Position.Side, binding.Position.Row, binding.Position.Col)
		bindingMap[key] = binding.Value
	}
	
	// Write function row (18 keys for Advanced Mod)
	sb.WriteString("    ")
	for i := 0; i < 18; i++ {
		key := fmt.Sprintf("left_%d_%d", 0, i) // Function row is row 0
		if val, ok := bindingMap[key]; ok {
			sb.WriteString(val)
		} else {
			sb.WriteString("&trans")
		}
		if i < 17 {
			sb.WriteString("  ")
		}
	}
	sb.WriteString("\n")
	
	// Write main keyboard rows (5 rows x 6 cols each side)
	for row := 1; row <= 5; row++ {
		sb.WriteString("    ")
		
		// Left side (6 keys)
		for col := 0; col < 6; col++ {
			key := fmt.Sprintf("left_%d_%d", row, col)
			if val, ok := bindingMap[key]; ok {
				sb.WriteString(val)
			} else {
				sb.WriteString("&trans")
			}
			sb.WriteString("  ")
		}
		
		// Add spacing/comment for visual separation
		sb.WriteString("                                                   ")
		
		// Right side (6 keys)
		for col := 0; col < 6; col++ {
			key := fmt.Sprintf("right_%d_%d", row, col)
			if val, ok := bindingMap[key]; ok {
				sb.WriteString(val)
			} else {
				sb.WriteString("&trans")
			}
			if col < 5 {
				sb.WriteString("  ")
			}
		}
		sb.WriteString("\n")
		
		// Thumb cluster rows need special handling (rows 6-8)
		if row == 5 {
			// Thumb cluster top row (4 keys each side)
			sb.WriteString("            ")
			for col := 0; col < 4; col++ {
				key := fmt.Sprintf("left_%d_%d", 6, col)
				if val, ok := bindingMap[key]; ok {
					sb.WriteString(val)
				} else {
					sb.WriteString("&trans")
				}
				sb.WriteString("  ")
			}
			sb.WriteString("                                                                  ")
			for col := 0; col < 4; col++ {
				key := fmt.Sprintf("right_%d_%d", 6, col)
				if val, ok := bindingMap[key]; ok {
					sb.WriteString(val)
				} else {
					sb.WriteString("&trans")
				}
				if col < 3 {
					sb.WriteString("  ")
				}
			}
			sb.WriteString("\n")
			
			// Thumb cluster middle row (2 keys each side)
			sb.WriteString("                                                  ")
			for col := 0; col < 2; col++ {
				key := fmt.Sprintf("left_%d_%d", 7, col)
				if val, ok := bindingMap[key]; ok {
					sb.WriteString(val)
				} else {
					sb.WriteString("&trans")
				}
				sb.WriteString("  ")
			}
			sb.WriteString("                                      ")
			for col := 0; col < 2; col++ {
				key := fmt.Sprintf("right_%d_%d", 7, col)
				if val, ok := bindingMap[key]; ok {
					sb.WriteString(val)
				} else {
					sb.WriteString("&trans")
				}
				if col < 1 {
					sb.WriteString("  ")
				}
			}
			sb.WriteString("\n")
			
			// Thumb cluster center (1 key each side)
			sb.WriteString("                                                          ")
			key := fmt.Sprintf("left_%d_%d", 8, 0)
			if val, ok := bindingMap[key]; ok {
				sb.WriteString(val)
			} else {
				sb.WriteString("&trans")
			}
			sb.WriteString("                                      ")
			key = fmt.Sprintf("right_%d_%d", 8, 0)
			if val, ok := bindingMap[key]; ok {
				sb.WriteString(val)
			} else {
				sb.WriteString("&trans")
			}
			sb.WriteString("\n")
			
			// Thumb cluster bottom (3 keys each side)
			sb.WriteString("                                        ")
			for col := 0; col < 3; col++ {
				key := fmt.Sprintf("left_%d_%d", 9, col)
				if val, ok := bindingMap[key]; ok {
					sb.WriteString(val)
				} else {
					sb.WriteString("&trans")
				}
				sb.WriteString("  ")
			}
			sb.WriteString("                                      ")
			for col := 0; col < 3; col++ {
				key := fmt.Sprintf("right_%d_%d", 9, col)
				if val, ok := bindingMap[key]; ok {
					sb.WriteString(val)
				} else {
					sb.WriteString("&trans")
				}
				if col < 2 {
					sb.WriteString("  ")
				}
			}
			sb.WriteString("\n")
		}
	}
}

// writeGenericBindings writes bindings in a generic format
func (g *ZMKGenerator) writeGenericBindings(sb *strings.Builder, layer *models.Layer) {
	// Simple row-based output
	currentRow := -1
	sb.WriteString("    ")
	
	for i, binding := range layer.Bindings {
		if binding.Position.Row != currentRow {
			if currentRow >= 0 {
				sb.WriteString("\n    ")
			}
			currentRow = binding.Position.Row
		}
		
		sb.WriteString(binding.Value)
		if i < len(layer.Bindings)-1 {
			sb.WriteString("  ")
		}
	}
	sb.WriteString("\n")
}
